\documentclass[utf8]{article}

\usepackage[utf8]{inputenc}

\usepackage[parfill]{parskip}

\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsfonts}
\usepackage{graphicx}
\usepackage{float}
\usepackage{listingsutf8}
\usepackage{hyperref}
\usepackage[dvipsnames]{xcolor}
\usepackage{comment}

\usepackage{fullpage}

%------------------------------------------------------

\usepackage{listings}
\usepackage{xcolor}

\definecolor{color0}{RGB}{147, 147, 147} %<--- I've changed this to make it more visible
\definecolor{color1}{RGB}{186, 033, 033}
\definecolor{color2}{RGB}{000, 128, 000}
\definecolor{color3}{RGB}{064, 128, 128}
\definecolor{color4}{RGB}{170, 034, 255}

\lstdefinelanguage{clips}{
  mathescape = true,
  sensitive        = true,
  morecomment      = [l]{;},
  showstringspaces = false,
  morestring       = [b]",
}

% egreg's modulo macro (see https://tex.stackexchange.com/a/34449/21891)
\def\truncdiv#1#2{((#1-(#2-1)/2)/#2)}
\def\moduloop#1#2{(#1-\truncdiv{#1}{#2}*#2)}
\def\modulo#1#2{\number\numexpr\moduloop{#1}{#2}\relax}


\makeatletter

% a TeX counter to keep track of the nesting level
\newcount\netParensCount@clisp

% Modify how ( and ) get typeset depending on the value of the counter
% (Based on Ulrike Fischer's approach to modifying characters in listings;
% see https://tex.stackexchange.com/a/231927/21891)
\lst@CCPutMacro
\lst@ProcessOther{`(}{{%
  \ifnum\lst@mode=\lst@Pmode\relax%
    \rainbow@clisp{(}%
    \global\advance\netParensCount@clisp by \@ne%
  \else
    (%
  \fi
}}%
\lst@ProcessOther{`)}{{%
  \ifnum\lst@mode=\lst@Pmode\relax%
    \global\advance\netParensCount@clisp by \m@ne%
    \rainbow@clisp{)}%
  \else
    )%
  \fi
}}%
\@empty\z@\@empty

% Color its argument based on the value of the \netParensCount@clisp counter
% (modulo 5)
\newcommand\rainbow@clisp[1]{%
  \ifcase\modulo\netParensCount@clisp 5\relax%
    \textcolor{color0}{#1}%
  \or
    \textcolor{color1}{#1}%
  \or
    \textcolor{color2}{#1}%
  \or
    \textcolor{color3}{#1}%
  \else
    \textcolor{color4}{#1}%
  \fi
}

\lst@AddToHook{PreInit}{%
  \global\netParensCount@clisp 0\relax%
}

\makeatother

\lstnewenvironment{clips-code}
  {\lstset{language=clips}}
  {}

\setcounter{tocdepth}{6}
\setcounter{secnumdepth}{6}

% -----------------------------------------------------


\title{SAT-solitaire}
\author{Fonseca Loïc - Bourgeois Noé}
\date{November 2021}

\begin{document}
\maketitle
\tableofcontents

\newpage

% -----------------------------------------------------

\section{Introduction}
Le Solitaire est un jeu de plateau classique à un seul joueur. 
Le plateau de jeu comporte des trous dans lesquels on peut mettre des billes. 
Pour jouer un coup au Solitaire, il faut choisir trois cases adjacentes, qui sont
toutes les trois sur une même ligne ou une même colonne du plateau. De surcroît,
exactement deux billes doivent être posées sur les trois cases, dont une posée sur
la case du milieu. On fait ”sauter” la bille qui se trouve sur une des extrémités
par dessus la bille du milieu, pour la faire atterrir dans le trou qui se trouve à
l’autre extrémité. On enlève alors la bille du milieu du plateau. La Figure 2 est
une représentation des différents coups possible, en utilisant la correspondance
entre matrice et configurations du jeu. Nous pouvons représenter une configuration du jeu par un entier positif n, et
une matrice de taille n × n dont les éléments appartiennent à {-1, 0, 1}. Si la
valeur de la case (i, j) de la matrice est égale à -1, alors il n’y a pas de trous
sur le plateau à la position (i, j); si cette valeur est égale à 0, alors il y a un
trou sur le plateau `a la position (i, j), mais il n’y a pas de bille posée dessus; 
si cette valeur est égale à 1, alors il y a un trou sur le plateau à la position (i, j) avec une bille posée dessus.

\section{Tests de satisfiabilité}
\subsection{ Données générales}
Soit $M$ une matrice de taille $L$ (nombre de lignes) * $C$ (nombre de colonnes)
dont les éléments sont dans \{-1, 0, 1\},
\\$f$, le nombre d'étapes pour atteindre une certaine configuration,
\label{nbEtapes}
\\$s$, l'étape actuelle, de la partie, $s\in \{1,...,S\}$ et $S$. Lors d'une partie, on joue forcément un seul coup par étape, et chaque coup élimine exactement une bille. $S$ est donc égal à la différence de billes entre le plateau original et le plateau final (ou le plateau final désiré).
\\Notons $D$, l'ensemble contenant les tuples directionnels, tel que $D=\{(1,0),(0,1),(-1,0),(0,-1)\}$
\\$d$, un tuple dans $D$ la direction du mouvement d'un coup, avec $d_0$ le premier élément du tuple et $d_1$ le second.

\subsection{Variables  Booléennes}
On commence par définir les variables de nos formules. 
\\La variable $x_{i,j,k,s}$
\\vaut “Vrai” si le nombre k est à la ligne $i$, colonne $j$ à l'étape $s$. 
\\La variable $m_{i,j,d,s}$
\\vaut “Vrai” si la bille à déplacer dans la direction d est à la ligne $i$, colonne $j$ à l'étape $s$. 


\subsection{Clauses relatives au jeu}
Nous avons 3 clauses définissant le fonctionnement du jeu.

\subsubsection{L'Etat du plateau: } 
Posons $A_s$ l'état du plateau à une étape $s\in S$, prenant en compte pour chaque position $(i,j)$, un litéral $x_k$ où $k\in \{-1,0,1\}$. \newline
$A_s = {\underset{\substack{i\in\{1,...,L\}\\j\in\{1,...,C\}}}{\bigwedge}}({\underset{k\in\{-1,0,1\}}{\bigvee}}x_{i,j,k,s})$ \newline
Il y a deux exceptions à cela pour le tableau de départ $A_1$ et le tableau de fin $A_S$ où les valeurs sont fixées, vu qu'on reçoit le tableau de départ en entrée, ainsi que le tableau de fin: 

\newline

$A_1 = {\underset{\substack{i\in\{1,...,L\}\\j\in\{1,...,C\}}}{\bigwedge}}(x_{i,j,k,1})$, 

où $k\in\{-1,0,1\}$, sur base du tableau reçu, et 

\newline

$A_S = {\underset{\substack{i\in\{1,...,L\}\\j\in\{1,...,C\}}}{\bigwedge}}(x_{i,j,k,S})$, 

où $k\in\{-1,0,1\}$, sur base du tableau reçu.

\begin{comment}

\subsubsection{\colorbox{orange}{non-case}}
Considérant une case (i,j)
variable 
x$_{i,j,k}$, 
les cases aux positions 
(i,j-1) variable x$_{i,j-1,k}$ 
et (i,j+1) variable x$_{i,j+1,k^\prime}$, 
sont des voisines
si et seulement si k,$k^ {\prime}$ != -1

\end{comment}

\subsubsection{Exactement une valeur par case: }
Dans chaque case (i, j), il doit y avoir exactement une seule valeur k.

En d’autre termes pour tout i,
pour tout j, pour tout k != k'
, on n’a pas $x_{i,j,k} ~ \land ~ x_{i,j,{k^\prime}}$.
\newline

$\overset{N}{\underset{i=1}{\bigwedge}}
~~\overset{N}{\underset{j=1}{\bigwedge}}$
$(~~\underset{-1<={k,k'}<=1}{\bigwedge}
\neg x_{i,j,k} ~ \lor ~ \neg x_{i,j,{k^\prime}})
 ~ \land ~ (x_{i,j,-1} ~ \lor ~ x_{i,j,0} ~ \lor ~ x_{i,j,1})$
 
\begin{comment}
 
\subsubsection{\colorbox{orange}{Voisin}}
On commence par définir ce qu’est un voisin : 
il s’agit d’une autre case dont les coordonnées ne sont pas éloignées de plus de 1.

$V (i, j) = {(i', j') \in [1, N]^2| max(|i - i'|, |j - j'| = 1)}$
 
Considérant une case (i,j) 
alors une voisine se trouve en (i,j-1) 
et l'autre en (i,j+1) 

Considérant une case x$_{i,j,k}$, alors une voisine se trouve en x$_{i,j-1,k^\prime}$ et l'autre en x$_{i,j+1,k^{\prime\prime}}$

$(x_{i,j-1,k} \lor ~~ x_{i,j-1,k^\prime} )
\land ~~
x_i,_j,_k 
\land ~~
(x_{i,j+1,k^\prime} \lor ~~ x_{i,j+1,k})$

\paragraph{sur même ligne}
Considérant une case (i,j) 
alors une voisine se trouve en (i,j-1) 
et l'autre en (i,j+1) 


%Si une variable x$_{i,j,k}$, 
%alors une voisine est %x$_{i,j-1,k^\prime}$ et l'autre en %x$_{i,j+1,k^{\prime}}$

$x_{i,j,1} \land ~~ 
((x_{i,j-1,1} \land x_{i,j+1,0}) \lor 
~~ (x_{i,j-1,0} \land x_{i,j+1,1}))$

\paragraph{sur même colonne}
Considérant une case (i,j) 
alors une voisine se trouve en (i-1,j) 
et l'autre en (i+1,j) 

%variable x$_{i,j,k}$, 
%alors une voisine se trouve en %x$_{i-1,j,k^\prime}$ et l'autre en %x$_{i+1,j,k^{\prime\prime}}$

$(x_{i-1,j,1} \lor ~~ x_{i-1,j,0} )
\land ~~
x_{i,j,1}
\land ~~
(x_{i+1,j,0} \lor ~~ x_{i+1,j,1})$

\end{comment}

\subsubsection{Clauses temporelle}
Ces clauses servent à verifier l'intégrite du plateau d'une étape à la prochaine, en effet il faut correctement déterminer l'état d'une case en fonction des étapes passées. \newline

Une première serait: Si à l'étape $s-1$, une case n'avait pas de bille ($k=0$) et que le coup approprié (à une distance de deux par rapport à la case en question dans la direction opposée du coup) a été joué, alors cette case a à présent une bille ($k=1$):\newline
$T_1 = {\underset{\substack{i\in\{1,...,L\} \\ j\in\{1,...,C\} \\ s\in \{1,...,S\}}}{\bigwedge}}((x_{i,j,0,s-1} \wedge ({\underset{d\in D}{\bigvee}}m_{i-2*d_0,j-2*d_1,d,s-1}))\rightarrow x_{i,j,1,s})$\newline

$T_1 = {\underset{\substack{i\in\{1,...,L\} \\ j\in\{1,...,C\} \\ s\in \{1,...,S\}}}{\bigwedge}}(\neg(x_{i,j,0,s-1} \wedge ({\underset{d\in D}{\bigvee}}m_{i-2*d_0,j-2*d_1,d,s-1}))\vee x_{i,j,1,s})$\newline

$T_1 = {\underset{\substack{i\in\{1,...,L\} \\ j\in\{1,...,C\} \\ s\in \{1,...,S\}}}{\bigwedge}}(\neg x_{i,j,0,s-1} \vee \neg({\underset{d\in D}{\bigvee}}m_{i-2*d_0,j-2*d_1,d,s-1})\vee x_{i,j,1,s})$\newline

La seconde serait: Si à l'étape $s-1$, une case avait une bille ($k=1$) et que le coup approprié (à une distance de un par rapport à la case en question dans la direction opposée du coup) a été joué, alors cette case n'a à présent plus de bille ($k=0$): \newline
$T_1 = {\underset{\substack{i\in\{1,...,L\} \\ j\in\{1,...,C\} \\ s\in \{1,...,S\}}}{\bigwedge}}((x_{i,j,1,s-1} \wedge ({\underset{d\in D}{\bigvee}}m_{i-d_0,j-d_1,d,s-1}))\rightarrow x_{i,j,0,s})$\newline

$T_1 = {\underset{\substack{i\in\{1,...,L\} \\ j\in\{1,...,C\} \\ s\in \{1,...,S\}}}{\bigwedge}}(\neg(x_{i,j,1,s-1} \wedge ({\underset{d\in D}{\bigvee}}m_{i-d_0,j-d_1,d,s-1}))\vee x_{i,j,0,s})$\newline

$T_1 = {\underset{\substack{i\in\{1,...,L\} \\ j\in\{1,...,C\} \\ s\in \{1,...,S\}}}{\bigwedge}}(\neg x_{i,j,1,s-1} \vee \neg({\underset{d\in D}{\bigvee}}m_{i-d_0,j-d_1,d,s-1})\vee x_{i,j,0,s})$\newline

\subsection{Déroulement d'une partie}
Considérons donc le cas général avec deux matrices, M et M'. Chacune représente un plateau de jeu à un certain état, M étant l'état de départ et M' l'état de fin ciblé. On peut savoir le nombre d'étapes $S$ nécessaire pour passer de M à M' en calculant la différence du nombre de billes entre les deux plateaux (voir \textbf{\nameref{nbEtapes}}), soit la différence de cases valant 1 dans les matrices.
\newline
La matrice M, nous permet donc de déduire $A_1$ et la matrice M' de déduire $A_S$.
\newline
Si on a un plateau $A_s$ alors on avait avant un plateau $A_{s-1}$ et un coup joué $m_{s-1}$. 

\begin{comment}
\subsubsection{\colorbox{red}{Coup}}
Nous avons défini un coup plus haut,
mais pour effectivement en jouer un,
il faut prendre en compte plusieurs
choses,
notamment, l'état du plateau, les
voisins en fonction de la direction
du coup, et bel et bien le fait
qu'on ne joue qu'un coup par
tour.\newline
Chaque tour un ensemble de coups
peuvent potentiellement être joués,
définissons la clause $J_s$,
l'ensemble des coups jouable à une
étape s.\newline
Pour chaque position (i,j) et chaque
direction d, nous pouvons jouer un
coup, si on ne joue pas d'autre coup
et que les voisins adéquats sont
bien une bille comme voisin direct
et un trou pour le voisin
d'après.
\newline
$J_s = {\underset{\substack{i\in\{1,...,L\} \\ j\in\{1,...,C\} \\ d\in D}}{\bigwedge}}((m_{i,j,d,s}\rightarrow (\neg ({\underset{d'\neq d ;i',j' \neq i,j}{\bigvee}}m_{i',j',d',s})\wegde {\underset{(i',j',k)\in \{(i,j,1);(i+d_0,j+d_1,1);(i+2*d_0,j+2*d_1,0)\}}{\bigwedge}}x_{i',j',k,s})$
\newline
---------------------
\newline

$J_s = {\underset{\substack{i\in\{1,...,L\} \\ j\in\{1,...,C\}}}{\bigwedge}}       
( \underset{d \in D }{\bigvee} (m_{i,j,d,s}\rightarrow \wegde {\underset{(i',j',k)\in \{(i,j,1);(i+d_0,j+d_1,1);(i+2*d_0,j+2*d_1,0)\}}{\bigwedge}}x_{i',j',k,s}))$
\newline
-----------------------
\newline
Qu'on peut transformer en: \newline
\newline
$J_s = {\underset{\substack{i\in\{1,...,L\} \\ j\in\{1,...,C\} \\ d\in D}}{\bigwedge}}((\neg m_{i,j,d,s}\vee (\neg ({\underset{d'\neq d ;i',j' \neq i,j}{\bigvee}}m_{i',j',d',s} \vee {\underset{(i',j',k)\in \{(i,j,1);(i+d_0,j+d_1,1);(i+2*d_0,j+2*d_1,0)\}}{\bigwedge}}x_{i',j',k,s})))$
\newline

\subsubsection{\colorbox{red}{Jouer un coup}}
Si on peut jouer un coup, alors, 
considérant une bille à la position (i,j) x$_{i,j,k}$, 
une de ses voisines
a forcément k = 1 et l'autre k = 0.\newline

Soit si x$_{i,j-1,1}$, x$_{i,j,1}$ et x$_{i,j+1,0}$, alors on peut jouer un coup tel que x$_{i,j-1,0}$, x$_{i,j,0}$ et x$_{i,j+1,1}$
\newline

\begin{clips-code}
    ((($x_{i,j-1,1} \land \neg x_{i,j+1,1}$) $\lor$ ($ x_{i,j-1,0} \land \neg x_{i,j+1,0}$)) $\land$ (($x_{i-1,j,1} \land \neg x_{i+1,j,1}$) $\lor$ ($ x_{i-1,j,0} \land \negx_{i+1,j,0}$)))
    
    $\land$ ($x_{i,j,1}$) 
------------------------------------

    ((($ x_{i,j-1,1,s}  \land x_{i,j+1,0,s} \land x_{i,j-1,0,s+1} \land x_{i,j+1,1,s+1} $) $\lor$ ($ x_{i,j-1,0,s} \land x_{i,j+1,1,s} \land x_{i,j-1,1,s+1} \land x_{i,j+1,0,s+1}$)) 
    $\lor$
    (($x_{i-1,j,1,s} \land x_{i+1,j,0,s} \land x_{i-1,j,0,s+1} \land x_{i+1,j,1,s+1}$) $\lor$ ($ x_{i-1,j,0,s} \land x_{i+1,j,1,s} \land x_{i-1,j,1,s+1} \land x_{i+1,j,0,s+1}$)))
    $\land$ ($x_{i,j,1,s} \land x_{i,j,0,s}$) 

\end{clips-code}

    % $\land$ $\neg$($ x_{i,j-1,-1} \lor x_{i-1,j,-1} \lor x_{i,j,-1} 
    % \lor x_{i,j+1,-1} \lor x_{i+1,j,-1}$)
\end{comment}

\subsection{ Mirroir }
Soit M' une matrice de même taille
dont les éléments sont aussi dans \{-1, 0, 1\},
On veut savoir si il est possible de passer de
la configuration du Solitaire
qui correspond à M 
à celle qui correspond à M'
, en effectuant un ou
plusieurs coups. 

\subsubsection{Clauses relatives au problème}

\[
\mathop{\mathbb{\bigwedge}}_{\substack{i \in \{1,..,L\},\\ j \in \{1,..,C\}}} x_{i,j, M'_{i,j}, f}
\]

\subsubsection{Formule Normale Conjonctive}
\textcolor{red}{(Question 1)}
\paragraph{Composition}

\subsubsection{Fonction "Solution"}
\textcolor{red}{(Question 2)}

\newpage

\subsection{ Dernière bille }
\subsubsection{Dans le trou de départ}
En se basant sur le programme précédent, 
un programme qui pour toute configuration de la Figure 1 (sauf la 6 et la
4), \\
teste s’il est possible d’atteindre une configuration du même plateau
mais qui contient une seule bille là où au départ il n’y avait pas de bille.

\paragraph{Clauses relatives au problème}
Le plateau final contient une seule bille là où au départ il n’y avait pas de bille.
Autrement dit, 
\\le 0 devient 1,
\\les 1 deviennent 0,
\\les -1 restent -1,

\[
\mathop{\mathbb{\bigwedge}}_{\substack{i \in \{1,..,L\},\\ j \in \{1,..,C\}}} x_{i,j, -\frac{M_{i,j} - 3(M_{i,j})^2}{2} + 1, f}
\]

\paragraph{Résultats}
\textcolor{red}{(Question 3)}


\subsubsection{ Peu importe où}
\paragraph{Clauses relatives au problème}

\paragraph{Résultats}
\textcolor{red}{(Question 4)}


\subsubsection{stratégie pour chaque possibilit´e de placer le trou au d´ebut}
\textcolor{red}{(Question 5)}

Pour le premier plateau de la Figure 1, on voudrait tester pour chaque possibilit´e de placer la trou au d´ebut, s’il existe une strat´egie pour n’avoir plus
qu’une seule bille `a la fin, plac´ee sur le trou de d´epart. Math´ematiquement,
4
consid´erons les matrices de la forme
o`u chaque bi ∈ {0, 1}. Pour tout i ∈ {1, . . . , 37}, on pose Mi
la matrice
o`u bi = 0 et bj = 1, pour tout j ∈ {1, . . . , 37} \ i. On pose ´egalement M0
i
le dual de Mi
: le 0 de Mi est reamplac´e par 1, et tous les 1 par des 0.
On veut maintenant construire la matrice R suivante: pour tout i ∈
{1, . . . , 37}, bi = 1 s’il existe une strat´egie pour passer de Mi `a M0
i
, sinon
bi = 0. Faire un programme qui calcule et affiche la matrice R, en utilsant
les questions pr´ec´edentes. Si le temps de calcul est trop long, vous pouvez
consid´erer un plateau de dimension inf´erieure.
\paragraph{Clauses relatives au problème}


% -----------------------------------------------------
\newpage

\section{Programs}

\subsection{ Mirroring Cannibal Sheeps }

\subsubsection{function}

\begin{figure}[H]
\begin{minipage}{\textwidth}
  \centering	
	\begin{lstlisting}
	function solution(m1, m2) 
    \end{lstlisting}
  \label{fig:code_exemple}
\end{minipage}
\end{figure}







\subsubsection{function}

\begin{figure}[H]
\begin{minipage}{\textwidth}
  \centering	
	\begin{lstlisting}
	function tornado(m1, m2) 
    \end{lstlisting}
  \label{fig:code_exemple}
\end{minipage}
\end{figure}

\paragraph{paragraph}:
    paragraph
    
  

\section{Résultats}
\begin{center}
\begin{tabular}{|c|c|c|c|
                |c|c|c|c|}
\hline
plateau taille & quantité billes & Mirror & Tornado \\
\hline
              &                &       &\\
             &                &               & \\
             &                &               & \\
             &                &               & \\
\hline
             &                &              & \\
\hline
\end{tabular}
\end{center}



\begin{figure}[H]
  \centering
	\includegraphics[scale=0.8]{img/Figure_1.png}
  \label{fig:logo}
\end{figure}

\newpage

\section{Discussion}
    

\section{Conclusion}


\end{document}
